// src/index.ts
import {createFilter} from "@rollup/pluginutils";
import * as changeCase from "change-case";
import {init, parse} from "es-module-lexer";
import MagicString from "magic-string";
import path from "path";
import {normalizePath} from "vite";
import {debug as Debug} from "debug";
import fs from "fs";
var debug = Debug("vite-plugin-style-import");
var ensureFileExts = [".css", "js", ".scss", ".less", ".styl"];
var isFn = (value) => value != null && Object.prototype.toString.call(value) === "[object Function]";
var src_default = (options) => {
  const {
    include = ["**/*.vue", "**/*.ts", "**/*.js", "**/*.tsx", "**/*.jsx"],
    exclude = "node_modules/**",
    root = process.cwd(),
    libs = []
  } = options;
  const filter = createFilter(include, exclude);
  let needSourcemap = false;
  let isBuild = false;
  debug("plugin options:", options);
  return {
    name: "vite:style-import",
    enforce: "post",
    configResolved(resolvedConfig) {
      needSourcemap = !!resolvedConfig.build.sourcemap;
      isBuild = resolvedConfig.isProduction || resolvedConfig.command === "build";
      debug("plugin config:", resolvedConfig);
    },
    async transform(code, id) {
      if (!code || !filter(id) || !needTransform(code, libs)) {
        return null;
      }
      await init;
      let imports = [];
      try {
        imports = parse(code)[0];
        debug("imports:", imports);
      } catch (e) {
        debug("imports-error:", e);
      }
      if (!imports.length) {
        return null;
      }
      let s;
      const str = () => s || (s = new MagicString(code));
      for (let index = 0; index < imports.length; index++) {
        const {n, se, ss} = imports[index];
        if (!n)
          continue;
        const lib = getLib(n, libs);
        if (!lib)
          continue;
        const isResolveComponent = isBuild && !!lib.resolveComponent;
        const importStr = code.slice(ss, se);
        const importVariables = transformImportVar(importStr);
        const importCssStrList = transformComponentCss(root, lib, importVariables);
        let compStrList = [];
        let compNameList = [];
        if (isResolveComponent) {
          const {componentStrList, componentNameList} = transformComponent(lib, importVariables);
          compStrList = componentStrList;
          compNameList = componentNameList;
        }
        debug("prepend import css str:", importCssStrList.join(""));
        debug("prepend import component str:", compStrList.join(""));
        const endIndex = se + 1;
        if (isBuild) {
          str().prependRight(endIndex, `
${compStrList.join("")}${importCssStrList.join("")}`);
        } else {
          str().append(`
${compStrList.join("")}${importCssStrList.join("")}`);
        }
        if (isResolveComponent && compNameList.some((item) => importVariables.includes(item))) {
          str().remove(ss, endIndex);
        }
      }
      return {
        map: needSourcemap ? str().generateMap({hires: true}) : null,
        code: str().toString()
      };
    }
  };
};
function transformComponentCss(root, lib, importVariables) {
  const {
    libraryName,
    resolveStyle,
    esModule,
    libraryNameChangeCase = "paramCase",
    ensureStyleFile = false
  } = lib;
  if (!isFn(resolveStyle) || !libraryName) {
    return [];
  }
  const set = new Set();
  for (let index = 0; index < importVariables.length; index++) {
    const name = getChangeCaseFileName(importVariables[index], libraryNameChangeCase);
    let importStr = resolveStyle(name);
    if (esModule) {
      importStr = resolveNodeModules(root, importStr);
    }
    let isAdd = true;
    if (ensureStyleFile) {
      isAdd = ensureFileExists(root, importStr, esModule);
    }
    isAdd && set.add(`import '${importStr}';
`);
  }
  debug("import css sets:", set.toString());
  return Array.from(set);
}
function transformComponent(lib, importVariables) {
  const {
    libraryName,
    resolveComponent,
    libraryNameChangeCase = "paramCase",
    transformComponentImportName
  } = lib;
  if (!isFn(resolveComponent) || !libraryName) {
    return {
      componentStrList: [],
      componentNameList: []
    };
  }
  const componentNameSet = new Set();
  const componentStrSet = new Set();
  for (let index = 0; index < importVariables.length; index++) {
    const libName = importVariables[index];
    const name = getChangeCaseFileName(importVariables[index], libraryNameChangeCase);
    const importStr = resolveComponent(name);
    const importLibName = isFn(transformComponentImportName) && transformComponentImportName(libName) || libName;
    componentStrSet.add(`import ${importLibName} from '${importStr}';
`);
    componentNameSet.add(libName);
  }
  debug("import component set:", componentStrSet.toString());
  return {
    componentStrList: Array.from(componentStrSet),
    componentNameList: Array.from(componentNameSet)
  };
}
function transformImportVar(importStr) {
  if (!importStr) {
    return [];
  }
  const exportStr = importStr.replace("import", "export").replace(/\s+as\s+\w+,?/g, ",");
  let importVariables = [];
  try {
    importVariables = parse(exportStr)[1];
    debug("importVariables:", importVariables);
  } catch (error) {
    debug("transformImportVar:", error);
  }
  return importVariables;
}
function ensureFileExists(root, importStr, esModule = false) {
  const extName = path.extname(importStr);
  if (!extName) {
    return tryEnsureFile(root, importStr, esModule);
  }
  if (esModule) {
    return fileExists(importStr);
  }
  return true;
}
function tryEnsureFile(root, filePath, esModule = false) {
  const filePathList = ensureFileExts.map((item) => {
    const p = `${filePath}${item}`;
    return esModule ? p : resolveNodeModules(root, p);
  });
  return filePathList.some((item) => fileExists(item));
}
function fileExists(f) {
  try {
    fs.accessSync(f, fs.constants.W_OK);
    return true;
  } catch (error) {
    return false;
  }
}
function getLib(libraryName, libs) {
  return libs.find((item) => item.libraryName === libraryName);
}
function getChangeCaseFileName(importedName, libraryNameChangeCase) {
  try {
    return changeCase[libraryNameChangeCase](importedName);
  } catch (error) {
    return importedName;
  }
}
function needTransform(code, libs) {
  return !libs.every(({libraryName}) => {
    return !new RegExp(`('${libraryName}')|("${libraryName}")`).test(code);
  });
}
function resolveNodeModules(root, ...dir) {
  return normalizePath(path.join(root, "node_modules", ...dir));
}
export {
  src_default as default,
  getChangeCaseFileName,
  transformImportVar
};
